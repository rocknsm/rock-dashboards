filter {
  if [@metadata][stage] == 'bro_category' {

    if [event][dataset] in ["conn", "dce_rpc", "dhcp", "dnp3", "dns", "ftp", "http", "irc", "kerberos", "modbus", "modbus_register_change", "mysql", "ntml", "radius", "rdp", "rfb", "sip", "smb_cmd", "smb_files", "smb_mapping", "smtp", "snmp", "socks", "ssh", "ssl", "syslog", "tunnel"] {

      if [@metadata][ENABLE_BRO_NETWORK] == "false" {
        # Configuration has disabled bro files events
        drop { }
      }

      mutate {
          rename => { "[%{[event][dataset]}][uid]" => "[event][id]" }
          merge => { "[related][id]" => "[event][id]" }
      }

      ## CONN ##################################################################
      if [conn] {
        mutate {
          merge => { "[related][id]" => "[conn][tunnel_parents]"}
          rename => { "[conn][proto]" => "[network][protocol]"}
          rename => { "[conn][service]" => "[network][application_id]"}
        }
      }

      ## DNS ###################################################################
      # if [dns][qtype] == 1 (A) or 28 (AAAA), split out answers to hostnames & ips
      # Nest the entire document
      if [dns] {
        ruby {
          path => "/etc/logstash/ruby/logstash-ruby-filter-dns-related.rb"
          script_params => {
            "query_field" => "[dns][query]"
            "query_type_field" => "[dns][qtype_name]"
            "answers_field" => "[dns][answers]"
          }
        }

        # Rename fields to ECS names
        mutate {
          rename => {
            "[dns][AA]" => "[dns][authoritative_answer]"
            "[dns][TC]" => "[dns][truncated]"
            "[dns][RD]" => "[dns][recursion_desired]"
            "[dns][RA]" => "[dns][recursion_available]"
            "[dns][qclass_name]" => "[dns][query_class]"
            "[dns][qtype_name]" => "[dns][query_type]"
            "[dns][rcode_name]" => "[dns][response_code]"
            "[dns][trans_id]" => "[dns][transaction_id]"
            "[dns][proto]" => "[network][protocol]"
          }
        }
      }
      ## FTP ###################################################################
      if [ftp] {
        mutate {
          merge => { "[related][id]" => "[ftp][fuid]"}
          add_field => { "[network][protocol]" => "tcp"}
        }
      }

      ## HTTP ##################################################################
      if [http] {
        # Parse domain names & IPs from host header
        ruby {
          path => "/etc/logstash/ruby/logstash-ruby-filter-http-host-related.rb"
          script_params => {
            "source_field" => "[http][host]"
          }
        }

        mutate { merge => { "[related][id]" => "[http][orig_fuids]" }}
        mutate { merge => { "[related][id]" => "[http][resp_fuids]" }}
        mutate { rename => { "[http][info_code]" => "[http][info][code]" }}
        mutate { rename => { "[http][info_msg]" => "[http][info][message]" }}
        mutate { rename => { "[http][orig_fuids]" => "[http][client][file_id]"}}
        mutate { rename => { "[http][orig_mime_types]" => "[http][client][mime_types]"}}
        mutate { rename => { "[http][request_body_len]" => "[http][request][body_length]"}}
        mutate { rename => { "[http][resp_fuids]" => "[http][server][file_id]"}}
        mutate { rename => { "[http][resp_mime_types]" => "[http][server][mime_types]"}}
        mutate { rename => { "[http][resp_filenames]" => "[http][server][filenames]"}}
        mutate { rename => { "[http][response_body_len]" => "[http][response][body_length]"}}
        mutate { rename => { "[http][status_code]" => "[http][status_code]"}}
        mutate { rename => { "[http][status_message]" => "[http][status_message]"}}
        mutate { rename => { "[http][trans_depth]" => "[http][transaction_depth]"}}
        mutate { copy => { "[http][server][filenames]" => "[file][name]"}}

        # This is debatable, but Bro won't detect HTTP over UDP or SCTP
        mutate { add_field => { "[network][protocol]" => "tcp"}}

        useragent {
          source => "[http][user_agent]"
          target => "user_agent"
        }

        mutate { rename => { "[http][user_agent]" => "[user_agent][original]"}}

      }

      ## IRC ###################################################################
      if [irc] {
        mutate {
          merge => { "[related][id]" => "[irc][fuid]"}
          add_field => { "[network][protocol]" => "tcp"}
        }
      }

      ## SIP ###################################################################
      if [sip] {
        useragent {
          source => "[sip][user_agent]"
          target => "user_agent"
        }

        mutate {
          rename => { "[sip][user_agent]" => "[user_agent][original]"}
          # This could go either way, but Bro only reads UDP currently
          add_field => { "[network][protocol]" => "udp"}
        }
      }
      ## SMB_Files #############################################################
      if [smb_files] {
        mutate {
          merge => { "[related][id]" => "[smb_files][fuid]" }
          add_field => { "[network][protocol]" => "tcp"}
        }
      }

      ## SMTP ##################################################################
      if [smtp] {
        mutate {
          merge => { "[related][id]" => "[smtp][fuids]" }
          merge => { "[related][ip]" => "[smtp][path]"}
          add_field => { "[network][protocol]" => "tcp"}
        }
        mutate {
          merge => { "[related][ip]" => "[smtp][x_originating_ip]"}
        }

        useragent {
          source => "[smtp][user_agent]"
          target => "user_agent"
        }

        mutate { rename => { "[smtp][user_agent]" => "[user_agent][original]"}}
      }

      if "[%{[event][dataset]}][proto]" {
        mutate { rename => { "[%{[event][dataset]}][proto]" => "[network][protocol]"}}
      }
      # This is for community-id support. Just painting with broad strokes
      if ![network][protocol] {
        if [event][dataset] in ["dce_rpc", "dhcp", "radius", "snmp", "syslog", "tunnel"] {
            mutate { add_field => { "[network][protocol]" => "udp"}}
        } else {
            mutate { add_field => { "[network][protocol]" => "tcp"}}
        }
      }


      mutate {
        add_field => { "[event][category]"   => "network"}
        replace =>   { "[@metadata][stage]" => "bro_network"}
      } # mutate
    }
  }
}
