filter {
    #### Base SIEM Field fixes/hacks for things like only work with packetbeat or aliases don't work for some things but work for others ####


    # Source.IP - fix field populate - Alias' don't work. https://github.com/elastic/kibana/blob/33c237e187156777f1344b49c4b8445658ade224/x-pack/legacy/plugins/siem/server/lib/ip_details/query_overview.dsl.ts#L28
    if [client][ip] {
        mutate { copy => { "[client]" => "[source]" } }
        if [source][as][organization][name] {
          mutate {
              copy => { "[source][as][organization][name]" => "[source][autonomous_system]" }
              add_field => { "autonomous_system" => "%{[source][as][organization][name]}" }
          }
        }
    }
    else if [source][as][organization][name] {
        mutate {
            copy => { "[source][as][organization][name]" => "[source][autonomous_system]"}
            add_field => { "autonomous_system" => "%{[source][as][organization][name]}" }
        }
    }

    # Destination.IP - fix field populate - Alias' don't work. https://github.com/elastic/kibana/blob/33c237e187156777f1344b49c4b8445658ade224/x-pack/legacy/plugins/siem/server/lib/ip_details/query_overview.dsl.ts#L28
    if [server][ip] {
        mutate { copy => { "[server]" => "[destination]" } }
        if [destination][as][organization][name] {
          mutate {
              copy => { "[destination][as][organization][name]" => "[destination][autonomous_system]" }
              add_field => { "autonomous_system" => "%{[destination][as][organization][name]}" }
          }
        }
    }
    else if [destination][as][organization][name] {
        mutate {
            copy => { "[destination][as][organization][name]" => "[destination][autonomous_system]"}
            add_field => { "autonomous_system" => "%{[destination][as][organization][name]}" }
        }
    }

    # Copy destination domain after Destination.IP and Source.IP alias fix, otherwise destination gets overwritten and thus would this field
    if [@metadata][destination_domain] {
        mutate {
            add_field => {
                "[destination][domain]" => "%{[@metadata][destination_domain]}"
                "[source][domain]" => "%{[@metadata][destination_domain]}"
            }
        }
    }

    # Overview tab - populate total event count - uses service.type
    if [event][module] == "zeek" {
        mutate { add_field => { "[service][type]" =>  "%{[event][module]}" } }
    }

    # TLS/SSL drill down - fix essentially the entirety of it, otherwise only works with packetbeat regardless of how (even filebeat with elastic ingest/process)
    if [ssl] {
        mutate { copy => { "[ssl]" =>  "[tls]" } }
        mutate {
            # ja3s hash currently not used, but maybe this will be future "proof"
            rename => {
                "[tls][ja3]" => "[tls][fingerprints][ja3][hash]"
                "[tls][ja3s]" => "[tls][fingerprints][ja3s][hash]"
                "[tls][client_issuer]" => "[tls][client_certificate][issuer][common_name]"
                "[tls][client_sha1]" => "[tls][client_certificate][fingerprint][sha1]"
                "[tls][client_subject]" => "[tls][client_certificate][subject][common_name]"
                "[tls][issuer]" => "[tls][server_certificate][issuer][common_name]"
                "[tls][server_sha1]" => "[tls][server_certificate][fingerprint][sha1]"
                "[tls][fingerprint]" => "[tls][server_certificate][fingerprint][sha1]"
                "[tls][subject]" => "[tls][server_certificate][subject][common_name]"
            }
        }
        # event.dataset and network.protocol are required for TLS to be available
        mutate {
            update => { "[event][dataset]" =>  "tls" }
            add_field => { "[network][protocol]" =>  "tls" }
        }
        # lastly, fingerprint sha1 is used as cardinality, and zeek/suricata don't have this field - but is added in RockNSM as of 2019-07-10......
        # therefore, check if it exists - otherwise for now "randomize" it just to create it so siem tls stuff works.
        # also, certificates don't really happen in TLS version 1.3 - and we still want to pivot/use the other stuff capture like JA3* hashes and stuff...
        if ![tls][server_certificate][fingerprint][sha1] {
            fingerprint {
                concatenate_sources => "true"
                method => "SHA1"
                source => [
                    "[ssl][ja3s]",
                    "[ssl][issuer]",
                    "[ssl][server_name]",
                    "[ssl][subject]"
                ]
                target => "[tls][server_certificate][fingerprint][sha1]"
                add_tag => "temporary siem tls fix"
            }
        }
    }

    # DNS/Domain drill down - most/all based on field dns.question.etld_plus_one exisiting. also requires the network.protocol field
    if [dns] {
        mutate {
            add_field => { "[network][protocol]" =>  "dns" }
            copy => { "[domain][1n2_name]" => "[dns][question][etld_plus_one]" }
            add_tag => "temporary siem dns fix"
        }
        # DNS bytes hack since only works with packetbeat which tracks that
        if ![source][bytes] {
          mutate {
            add_field => {
              "[source][bytes]" =>  "0"
              "[destination][bytes]" =>  "0"
            }
          }
        }
    }

    # Final Hacks for Zeek fields
    if [event][module] == "zeek" {
        mutate { copy => { "[event][id]" => "[zeek][session_id]" } }
    }
    # Final Hacks for Suricata fields
    if [event][module] == "suricata" {
        mutate {
          copy => {
            "[network][protocol]" => "[suricata][eve][proto]"
            "[alert][signature]" => "[suricata][eve][alert][signature]"
            "[alert][signature_id]" => "[suricata][eve][alert][signature_id]"
          }
        }
    }
}