filter {
  if [@metadata][stage] == 'bro_json' {
    # Set the timestamp
    date { match => [ "ts", "ISO8601" ] }

    # move metadata to new field
    mutate {
      rename => {
        "@stream" => "[event][category]"
        "@system" => "[event][system]"
        "@proc"   => "[event][bro][process]"
      }
      # Clean these up later if empty
      add_field => { "[related][hostname]" => []}
      add_field => { "[related][ip]" => []}
      add_field => { "[related][id]" => []}
      add_field => { "[related][hash]" => []}
    }

    if [event][category] == "files" {
      mutate { replace => {"[event][category]" => "file" }}
    }
    # Nest the entire document
    ruby {
      code => "
        require 'logstash/event'

        logtype = event.get('[event][category]')

        ev_hash = event.to_hash
        event_hash = ev_hash['event']
        timestamp = ev_hash['@timestamp']

        # Cleanup duplicate info
        ev_hash.delete('event')
        ev_hash.delete('@timestamp')
        ev_hash.delete('@version')
        ev_hash.delete('tags')

        result = {
        logtype => ev_hash,
        'event' => event_hash,
        '@timestamp' => timestamp
        }
        event.initialize( result )
      "
    }

    if "[%{[event][category]}][id_orig_h]" {
      # Common connection-oriented log information
      mutate {
        rename => {
          "[%{[event][category]}][id_orig_h]" => "[network][client][ip]"
          "[%{[event][category]}][id_orig_p]" => "[network][client][port]"
          "[%{[event][category]}][id_resp_h]" => "[network][server][ip]"
          "[%{[event][category]}][id_resp_p]" => "[network][server][port]"
        }

        # Format data
        convert => {
          "[network][client][port]" => "integer"
          "[network][server][port]" => "integer"
        }
      }

      # Add GeoIP Info
      geoip {
        source => "[network][client][ip]"
        target => "[network][client][geo]"
        default_database_type => "City"
      }
      geoip {
        source => "[network][server][ip]"
        target => "[network][server][geo]"
        default_database_type => "City"
      }
      geoip {
        source => "[network][client][ip]"
        target => "[network][client][geo]"
        default_database_type => "ASN"
      }
      geoip {
        source => "[network][server][ip]"
        target => "[network][server][geo]"
        default_database_type => "ASN"
      }

      mutate {
        # Related data
        merge => { "[related][ip]" => "[network][client][ip]" }
      }

      # Need to have distinct mutate filter for the merge to work
      mutate {
        merge => { "[related][ip]" => "[network][server][ip]" }
      }
    }

    mutate { replace => { "[@metadata][stage]" => "bro_category" } }
  }
}
