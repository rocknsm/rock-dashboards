filter {
  if [@metadata][stage] == 'bro_tagged_json' {

    if [event][category] in ["intel", "notice", "notice_alarm", "signatures", "traceroute"] {

      mutate {
        add_field => { "[event][module]" => "detection" }
      }

      ruby {
        code => '
        # This code loops through the event and moves out the IPs, Ports, and UIDs
        # This list of streams needs to be the same list as the event category above
        streams = ["intel", "notice", "notice_alarm", "signatures", "traceroute"]

        streams.each do |stream|
          if event.has_key? stream
            if event["#{stream}"].has_key? "id_orig_h"
              event.merge!({
                "event" => { "id" => event["#{stream}"]["uid"] },
                "network" => {
                  "client" => {
                    "ip" => event["#{stream}"]["id_orig_h"],
                    "port" => event["#{stream}"]["id_orig_p"]
                  },
                  "server" => {
                    "ip" => event["#{stream}"]["id_resp_h"],
                    "port" => event["#{stream}"]["id_resp_p"]
                  }
                }
              })
              # Remove the copied fields
              event["#{stream}"] = event["#{stream}"].select{|x| !["uid", "id_orig_h", "id_orig_p", "id_resp_h", "id_resp_p"].include?(x)}
            end
          end
        end
        '
      }

      # Format data types
      mutate {
        convert => {
          "[network][client][port]" => "integer"
          "[network][client][port]" => "integer"
        }

        # Related data
        merge => {
          "[related][ip]" => "[network][client][ip]"
          "[related][ip]" => "[network][server][ip]"
          "[related][id]" => "[event][id]"
        }
      }

      mutate {
        add_field => {
          "[event][module]" => "network"
          "[@metadata][stage]" => "bro_network"
        }
      } # mutate
    }
  }
}
